<html server-rendered="true"><head><meta charset="UTF-8"> <meta name="viewport" content="initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width,user-scalable=no"> <meta name="renderer" content="webkit"> <meta name="theme-color" content="#ffffff"> <link href="/css/build.HomePage.css" rel="stylesheet"> <link href="/css/build.PostPage.css" rel="stylesheet"> <title> Minghe </title></head><section class="post-view"><h1 class="post-title">
    细说Python的并发与并行
    <time pubdate="pubdate" class="post-date"></time></h1> <article><p>让我们来完成一个简单的 <a href="">Artifactory</a> 客户端来深入的熟悉一下 Python 的并行和并发吧。所以我们的需求是这样的: 我们的客户端可以遍历任何的路径，列举处这个目录下的所有文件, 而且尽量快的展示结果，好比如所说我们点击一个文件，要尽量的给我们展示其下面的文件一样，显然这里的性能瓶颈是获取子目录的时间消耗。对于 Artifactory 更是如此，因为每一次获取子目录都是一个 HTTP 请求，那么我们如何可以以最快的速度获取某个目录下面的所有文件呢?</p>
<h3 id="并行和并发">并行和并发</h3><p>这个概念很多人都分不清，显然我自己也没法给处一个权威的解释，不过下面的两个 talk 可以听听，也许你可以了解到到底什么是并发 ( concurrency)，什么是并行(parallelism).</p>
<ul>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism">concurrency is not parallelism</a></li>
<li><a href="https://www.amazon.cn/%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B-%E5%B8%83%E5%BD%BB/dp/B00V4B2KEI/ref=sr_1_1?ie=UTF8&amp;qid=1472529795&amp;sr=8-1&amp;keywords=%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91">七周七并发模型</a></li>
</ul>
<p><a href="https://www.amazon.cn/Effective-Python-%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FPython%E4%BB%A3%E7%A0%81%E7%9A%8459%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95-%E5%B8%83%E9%9B%B7%E7%89%B9%C2%B7%E6%96%AF%E6%8B%89%E7%89%B9%E9%87%91/dp/B01ASI36QS/ref=sr_1_1?ie=UTF8&amp;qid=1472529988&amp;sr=8-1&amp;keywords=effective+python">effective Python</a> 中是这么说的，并行和并发的关键区别，在于能不能提速(speedup), 某程序若是并行程序，其中有多条不同的执行路径都在平行的向前推进，则总任务的执行时间会减半，执行速度会变成普通程序的两倍，反之，如果该程序是并发程序，那么它即使可以使用看似平行的方式分别执行多条路径，也依然不会是总任务的执行速度得到提升。我对这种解释是不认可的。</p>
<p>我自己简单的理解是: 并发是设计，并行是程序的运行状态。所以才会有多种的并发模型，而这些模型的目的就是为了让程序过程达到并行的状态。</p>
<h3 id="设计一个高效的-artifactory-客户端">设计一个高效的 Artifactory 客户端</h3><p>任何树状模型的结构的遍历无非就是两种: 深度优先 (Depth-First-Search) 和 广度优先 (Breadth-First-Search), 对于二叉树来说，深度优先遍历还可以分为: 前序，中序，和后序遍历三种，区别就是根节点访问的顺序。对于目录的访问来说，显然是广度优先的算法，每次都是获取都是目录树某一层的所有节点, 根据 Artifactory 的 <a href="https://www.jfrog.com/confluence/display/RTF/Artifactory+REST+API">REST API</a>, 我们的节点访问可以是这样的.</p>
<pre><code class="lang-undefined"><span class="token keyword">import</span> requests

def <span class="token function">visit</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
  res <span class="token operator">=</span> requests<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>
  dict <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> dict<span class="token punctuation">[</span><span class="token string">'children'</span><span class="token punctuation">]</span>
  except KeyError<span class="token punctuation">:</span>
    <span class="token keyword">return</span> None</code></pre><ul>
<li>done comes first</li>
</ul>
<p>本着&#39;done comes first&#39;的原则，我们第一可以工作的 Artifactory 客户端是这样的</p>
<pre><code class="lang-undefined"><span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>
  def <span class="token function">tree</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">:</span>
      def <span class="token function">travel</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> items<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
          children <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">get_children</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>
          <span class="token keyword">if</span> stat<span class="token punctuation">.</span>children<span class="token punctuation">:</span>
              <span class="token keyword">for</span> p <span class="token keyword">in</span> <span class="token punctuation">[</span>stat<span class="token punctuation">.</span>uri <span class="token operator">+</span> c<span class="token punctuation">[</span><span class="token string">'uri'</span><span class="token punctuation">]</span> <span class="token keyword">for</span> c <span class="token keyword">in</span> stat<span class="token punctuation">.</span>children<span class="token punctuation">]</span><span class="token punctuation">:</span>
                  <span class="token function">travel</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> items<span class="token punctuation">)</span>
          <span class="token keyword">else</span><span class="token punctuation">:</span>
              items<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>

      items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
      <span class="token function">travel</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> items<span class="token punctuation">)</span>
      <span class="token keyword">return</span> items</code></pre><p>假设我们的目录是这样子:</p>
<pre><code class="lang-undefined">  <span class="token operator">-</span>a
    <span class="token operator">-</span> a1
      <span class="token operator">-</span> a11
      <span class="token operator">-</span> a12
      <span class="token operator">-</span> a13
    <span class="token operator">-</span> a2
      <span class="token operator">-</span> a21
      <span class="token operator">-</span> a22
      <span class="token operator">-</span> a23</code></pre><p>当我们其实我们的 client.tree(a) 最后的得到的结果会是我们预想的:</p>
<pre><code class="lang-undefined">a<span class="token operator">/</span>a1<span class="token operator">/</span>a11
a<span class="token operator">/</span>a1<span class="token operator">/</span>a12
a<span class="token operator">/</span>a1<span class="token operator">/</span>a13
a<span class="token operator">/</span>a2<span class="token operator">/</span>a21
a<span class="token operator">/</span>a2<span class="token operator">/</span>a22
a<span class="token operator">/</span>a2<span class="token operator">/</span>a23</code></pre><p>然而我们需要的时间是: T(a) + T(a1) + T(a2) + T(a11) + T(a12) + T(a13) + T(a21) + T(a22) + T(a23), T(n) 表示去获取节点 n 的时间，获取节点 n 的目的是为了检查其是否有子节点.</p>
<ul>
<li>优化一下</li>
</ul>
<p>稍微分析一下，在广度优先中，在同一级的节点中，比如 a1, a2，获取他们的子节点的时候，因为没有任何依赖，也就是可以并行进行的。那么我们是否可以用多线程去完成呢，答案是否定，原因是因为 Python 的多线程并不会真的并不会提高我们的任务时间利用率，因为 Python 的 GIL (Global Interpreter Lock), 这是一个 mutex，由于 CPython 的内存管理不是线程安全，所以这个 mutex 起到防止多个线程同时执行。所有当你在  Python 中使用多线程的时候，真实情况是这样的:</p>
<pre><code class="lang-undefined">thread<span class="token operator">-</span>A <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span>
thread<span class="token operator">-</span>B  <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span> <span class="token operator">-</span></code></pre><p>可以看出线程 A 和线程 B 在同一个时间单位里只有一个线程在运行，所以总的运行时间并不能减少。所以尝试使用多线程来做并行计算并不能达到我们的需求。那么拿到我们就没有办法加快我的程序了吗？</p>
<p>当然不是，多线程不行，那么为什么不用多进程呢? 所以我们的代码可以这样.</p>
<pre><code class="lang-undefined">def <span class="token function">walk_tree</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> walk_func<span class="token punctuation">)</span><span class="token punctuation">:</span>
    store <span class="token operator">=</span> <span class="token function">Store</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>

    <span class="token keyword">while</span> not store<span class="token punctuation">.</span><span class="token function">is_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        pool <span class="token operator">=</span> <span class="token function">ProcessPoolExecutor</span><span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
        all_nodes <span class="token operator">=</span> store<span class="token punctuation">.</span><span class="token function">pollall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> n <span class="token keyword">in</span> all_nodes<span class="token punctuation">:</span>
            store<span class="token punctuation">.</span><span class="token function">visiting</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>

        results <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>walk_func<span class="token punctuation">,</span> all_nodes<span class="token punctuation">)</span>
        <span class="token keyword">for</span> node<span class="token punctuation">,</span> children <span class="token keyword">in</span> results<span class="token punctuation">:</span>
            store<span class="token punctuation">.</span><span class="token function">visited</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>

            <span class="token keyword">if</span> children<span class="token punctuation">:</span>
                <span class="token keyword">for</span> c <span class="token keyword">in</span> children<span class="token punctuation">:</span>
                    store<span class="token punctuation">.</span><span class="token function">to_visit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                store<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span>

    <span class="token keyword">return</span> store</code></pre><p>可以看到我们使用 ProcessPoolExecutor 来实现我们的多进程，这个来自与 concurrency.futures 这个模块 (Python 2, Python 3 它变成了 futures). 这个模块是对 multiprocessing 这个模块的封装，让我们可以很方便的进行多线程的管理。</p>
<p>这是一个通用的树状结构遍历方法，给它一个根节点，以及一个节点信息获取的方法，它就可以多进程的获取一棵树的所有节点了。</p>
<h3 id="show-me-the-codes">show me the codes</h3><p>这篇文章的完整思路都这个 Artifactory 客户端, 开源在 GitHub 上.</p>
<p><a href="https://github.com/metrue/artifactor">artifactor</a></p>
</article></section><footer class="footer">
  Copyright ©2014-2017 <a href="http://minghe.me"> minghe.me</a> | Powered by <a href="https://github.com/metrue/Seal">Seal</a> on top of <a href="https://vuejs.org" target="_blank">Vue.js</a></footer></html>