<html server-rendered="true"><head><meta charset="UTF-8"> <meta name="viewport" content="initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width,user-scalable=no"> <meta name="renderer" content="webkit"> <meta name="theme-color" content="#ffffff"> <link href="/css/build.HomePage.css" rel="stylesheet"> <link href="/css/build.PostPage.css" rel="stylesheet"> <title> Minghe </title></head><section class="post-view"><h1 class="post-title">
    基于Docker的无痛部署
    <time pubdate="pubdate" class="post-date"></time></h1> <article><p>作为一个全栈(全沾)工程师，你一个人负责着产品的方方面面，从前端的切图，到后端的数据库，你无所不惧，无所不能，可是日理万机的你，日以继夜的做出一个优秀的产品了之后，终于要生产环境部署服务，然后准备向用户开放了，可是你却开始开始犯难了，怎么才能够无痛持续部署呢？其实任何程序的运行都是基于特定环境，那么只要保证环境稳定，那么程序正常运行的基础才能保证。而且环境稳定的最佳保证方式我觉得是环境独立，而保证环境独立的最佳方式当然是容器技术了，这篇文章我将介绍我自己怎么实用 Docker 进行无痛部署的。</p>
<h3 id="准备条件">准备条件</h3><p>本文针对的场景是: 个人或者小团队正在开发一个小产品。这样的场景下假设我们是没有使用任何的 CI, CD 服务，比如 Jenkins, Bamboo 等工具的。我所拥有的就是我的开发本(一台Mac, 或者 *nix 机器), 一台等待部署的生产环境云主机. 就这么简单.</p>
<ul>
<li>开发环境的 Docker 环境配置</li>
</ul>
<p>现在 Docker 已经了 Mac 版的，详细的安装方式可以参考这篇官方文档。 <a href="https://docs.docker.com/docker-for-mac/">docker for mac</a>, 安装好了启动好了。简单检查一下你的 Docker 是否安装妥当。</p>
<pre><code class="lang-undefined">$ docker info # 看看整体信息

$ docker <span class="token operator">--</span>version

$ docker<span class="token operator">-</span>compose <span class="token operator">--</span>version

$ docker<span class="token operator">-</span>machine <span class="token operator">--</span>version</code></pre><h3 id="项目分解">项目分解</h3><p>我们的产品终于开发好了，假设我们很好的对我们的产品进行了基于服务的结构分离，我们的整个产品 break down 成为了下面的几个部分:</p>
<ul>
<li>Mongo 数据库</li>
<li>API Server 后端API</li>
<li>前端</li>
</ul>
<p>基于这样的架构，我们需要的部署的服务将是这样的:</p>
<ul>
<li>Mongo</li>
<li>API Server</li>
<li>Nginx</li>
</ul>
<p>这三者分别作为独立的服务以 Docker Container 的形式存在，其中 Mongo 作为数据库服务，API Server 显然是承担着后端 API 服务，Nginx 负责 Proxy 网站前端以及 API Server, 也就是 Nginx 基于 location 或者 server_name 来决定应该转发到我们的 Web 前端还是后端 API Server. 所以我们的 nginx.conf 可能是这样的:</p>
<pre><code class="lang-undefined">user nginx<span class="token punctuation">;</span>
worker_processes auto<span class="token punctuation">;</span>
pid <span class="token operator">/</span>run<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid<span class="token punctuation">;</span>

events <span class="token punctuation">{</span>
    worker_connections <span class="token number">768</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

http <span class="token punctuation">{</span>
    sendfile on<span class="token punctuation">;</span>
    tcp_nopush on<span class="token punctuation">;</span>
    tcp_nodelay on<span class="token punctuation">;</span>
    keepalive_timeout <span class="token number">65</span><span class="token punctuation">;</span>
    types_hash_max_size <span class="token number">2048</span><span class="token punctuation">;</span>

    include <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>mime<span class="token punctuation">.</span>types<span class="token punctuation">;</span>
    default_type application<span class="token operator">/</span>octet<span class="token operator">-</span>stream<span class="token punctuation">;</span>

    ssl_protocols TLSv1 TLSv1<span class="token number">.1</span> TLSv1<span class="token number">.2</span><span class="token punctuation">;</span> # Dropping SSLv3<span class="token punctuation">,</span> ref<span class="token punctuation">:</span> POODLE
    ssl_prefer_server_ciphers on<span class="token punctuation">;</span>

    access_log <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>access<span class="token punctuation">.</span>log<span class="token punctuation">;</span>
    error_log <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>log<span class="token operator">/</span>nginx<span class="token operator">/</span>error<span class="token punctuation">.</span>log<span class="token punctuation">;</span>

    gzip on<span class="token punctuation">;</span>
    gzip_disable <span class="token string">"msie6"</span><span class="token punctuation">;</span>

  server <span class="token punctuation">{</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>

    location <span class="token operator">/</span> <span class="token punctuation">{</span>
      root <span class="token operator">/</span>opt<span class="token operator">/</span>sira<span class="token operator">/</span>web<span class="token operator">/</span><span class="token keyword">public</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    location <span class="token operator">/</span>v1<span class="token operator">/</span>api <span class="token punctuation">{</span>
      proxy_pass http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>api<span class="token punctuation">:</span><span class="token number">5001</span><span class="token punctuation">;</span>
      proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>
      proxy_set_header Upgrade $http_upgrade<span class="token punctuation">;</span>
      proxy_set_header Connection <span class="token string">'upgrade'</span><span class="token punctuation">;</span>
      proxy_set_header Host $host<span class="token punctuation">;</span>
      proxy_cache_bypass $http_upgrade<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre><p>如果我们是用 server_name 来控制的，那么 server section 可能是这样的。</p>
<pre><code class="lang-undefined">server <span class="token punctuation">{</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    server_name example<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

server <span class="token punctuation">{</span>
    listen <span class="token number">80</span><span class="token punctuation">;</span>
    server_name api<span class="token punctuation">.</span>example<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3 id="准备-dockerfile">准备 dockerfile</h3><p>dockerfile 的最佳文档当然是官方文档了,<a href="https://docs.docker.com/engine/reference/builder/">docker file</a>，当然如果你的技术栈和我的差不多的话: Mongo + Koa + React，全都是 ES6 的话，你可以参考我的dockerfile.</p>
<ul>
<li>Mongo 的dockerfile</li>
</ul>
<pre><code class="lang-undefined">FROM mongo</code></pre><p>Mongo 的 dockerfile 其实什么也没有做，就是基于官方的 Mongo 镜像而已，独立写一份只是为了后面的拓展方便.</p>
<ul>
<li>API Server 的dockerfile</li>
</ul>
<pre><code class="lang-undefined">FROM alpine<span class="token punctuation">:</span><span class="token number">3.4</span>

RUN apk add <span class="token operator">--</span>update nodejs
RUN apk add <span class="token operator">--</span>update python
RUN apk add <span class="token operator">--</span>update make
RUN apk add <span class="token operator">--</span>update gcc
RUN apk add <span class="token operator">--</span>update g<span class="token operator">++</span>

RUN mkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>laivei<span class="token operator">-</span>server
WORKDIR <span class="token operator">/</span>opt<span class="token operator">/</span>laivei<span class="token operator">-</span>server
ADD server <span class="token punctuation">.</span>

# Fix bug https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>npm<span class="token operator">/</span>npm<span class="token operator">/</span>issues<span class="token operator">/</span><span class="token number">9863</span>
RUN cd <span class="token function">$</span><span class="token punctuation">(</span>npm root <span class="token operator">-</span>g<span class="token punctuation">)</span><span class="token operator">/</span>npm \
 <span class="token operator">&amp;&amp;</span> npm install fs<span class="token operator">-</span>extra \
  <span class="token operator">&amp;&amp;</span> sed <span class="token operator">-</span>i <span class="token operator">-</span>e s<span class="token operator">/</span>graceful<span class="token operator">-</span>fs<span class="token operator">/</span>fs<span class="token operator">-</span>extra<span class="token operator">/</span> <span class="token operator">-</span>e s<span class="token operator">/</span>fs\<span class="token punctuation">.</span>rename<span class="token regex">/fs.move/</span> <span class="token punctuation">.</span><span class="token operator">/</span>lib<span class="token operator">/</span>utils<span class="token operator">/</span>rename<span class="token punctuation">.</span>js

RUN npm install
RUN npm run transpile

EXPOSE <span class="token number">5001</span>

CMD <span class="token punctuation">[</span><span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"run"</span><span class="token punctuation">,</span> <span class="token string">"start"</span><span class="token punctuation">]</span></code></pre><p>API Server 的 dockerfile 基于的是 alpine 这个超轻量级的 linux, 然后编译运行我们的服务,并且暴露出特定端口.</p>
<ul>
<li>Nginx 的dockerfile</li>
</ul>
<pre><code class="lang-undefined">FROM nginx<span class="token punctuation">:</span>alpine
COPY devops<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf <span class="token operator">/</span>etc<span class="token operator">/</span>nginx<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf

RUN apk add <span class="token operator">--</span>update nodejs
RUN apk add <span class="token operator">--</span>update python
RUN apk add <span class="token operator">--</span>update make
RUN apk add <span class="token operator">--</span>update gcc
RUN apk add <span class="token operator">--</span>update g<span class="token operator">++</span>

RUN mkdir <span class="token operator">-</span>p <span class="token operator">/</span>opt<span class="token operator">/</span>sira<span class="token operator">/</span>web
WORKDIR <span class="token operator">/</span>opt<span class="token operator">/</span>sira<span class="token operator">/</span>web
COPY web <span class="token punctuation">.</span>

RUN npm install
RUN npm run build

EXPOSE <span class="token number">80</span></code></pre><p>Nginx 这个docker file 做了两件事情，设置 nginx.conf，然后编译前端。当然我们也可以把编译前端的这一部分工作放到单独的服务里面去做。至此，我们的整个产品的 docker 化就算完成了. 你可以验证你的 dockerfile 是否已经准备妥当了.</p>
<pre><code class="lang-undefined">docker build <span class="token operator">-</span>f devops<span class="token operator">/</span>dockerfile<span class="token punctuation">.</span>mongo <span class="token punctuation">.</span>
docker run <span class="token operator">&lt;</span>image<span class="token operator">></span></code></pre><p>其他的服务类似.</p>
<h3 id="docker-compose">docker-compose</h3><p>至此呢，我们已经完成了所有的 dockerfile 了， 当然我们可以每一个服务都单独去运行，但是有一种更好的方式去组织我们的整个产品: <a href="https://docs.docker.com/compose/">Docker Compose</a>. docker-compose 做两件事情:</p>
<ul>
<li>定义整个产品的构成，也就是有哪些 container 来组成</li>
<li>运行整个产品</li>
</ul>
<p>docker-compose 的输入是 docker-compose.yml 文件, 假设我们的产品代码的目录结构是这样子的:</p>
<pre><code class="lang-undefined">$ ls
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x crawler
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x devops
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x server
drwxr<span class="token operator">-</span>xr<span class="token operator">-</span>x web</code></pre><p>基于我们的产品架构，我们的 compose file 是这样子的.</p>
<pre><code class="lang-undefined">version<span class="token punctuation">:</span> <span class="token string">'2'</span>
services<span class="token punctuation">:</span>
  mongo<span class="token punctuation">:</span>
    build<span class="token punctuation">:</span>
      context<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>
      dockerfile<span class="token punctuation">:</span> devops<span class="token operator">/</span>dockerfile<span class="token punctuation">.</span>mongo
    volumes<span class="token punctuation">:</span>
      <span class="token operator">-</span> <span class="token operator">/</span>data<span class="token operator">/</span>sira<span class="token operator">/</span>db<span class="token punctuation">:</span><span class="token operator">/</span>data<span class="token operator">/</span>db
  api<span class="token punctuation">:</span>
    build<span class="token punctuation">:</span>
      context<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>
      dockerfile<span class="token punctuation">:</span> devops<span class="token operator">/</span>dockerfile<span class="token punctuation">.</span>server
    ports<span class="token punctuation">:</span>
      <span class="token operator">-</span> <span class="token string">'5001:5001'</span>
    depends_on<span class="token punctuation">:</span>
      <span class="token operator">-</span> mongo
    links<span class="token punctuation">:</span>
      <span class="token operator">-</span> mongo
  nginx<span class="token punctuation">:</span>
    build<span class="token punctuation">:</span>
      context<span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>
      dockerfile<span class="token punctuation">:</span> devops<span class="token operator">/</span>dockerfile<span class="token punctuation">.</span>nginx
    ports<span class="token punctuation">:</span>
      <span class="token operator">-</span> <span class="token string">'80:80'</span>
    depends_on<span class="token punctuation">:</span>
      <span class="token operator">-</span> api
    links<span class="token punctuation">:</span>
      <span class="token operator">-</span> api</code></pre><p>由此你可以大致了解到，我们可以在 compose file 中定义整个产品的各个组成部分的依赖逻辑，定义各个服务的构建信息，各个服务所需的 volumns, ports 等等。当然能做的还有更多，你可以参考这个这个官方文档: <a href="https://docs.docker.com/compose/compose-file/">compose file</a>.</p>
<h3 id="一键部署">一键部署</h3><p>到此，我们整个产品就已经完成了 docker-based 的部署方案了，敲下一下命令，然后愉快的访问你的网站把.</p>
<pre><code class="lang-undefined">docker<span class="token operator">-</span>compose <span class="token operator">-</span>f devops<span class="token operator">/</span>compose<span class="token punctuation">.</span>yml build <span class="token operator">&amp;&amp;</span> docker<span class="token operator">-</span>compose <span class="token operator">-</span>f devops<span class="token operator">/</span>compose<span class="token punctuation">.</span>yml up <span class="token operator">-</span>d</code></pre><p>当然，在实际实践中，我们可以写一个简单的部署脚本，然后准备一个简单的Makefile:</p>
<pre><code class="lang-undefined">#<span class="token operator">!</span><span class="token operator">/</span>bin<span class="token operator">/</span>bash

env<span class="token operator">=</span>$<span class="token number">1</span>

dev_host<span class="token operator">=</span><span class="token string">'root@106.185.xxx.yyy'</span>
prod_host<span class="token operator">=</span><span class="token string">'root@139.162.aaa.bbb'</span>

target_host<span class="token operator">=</span>$dev_host
<span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> $env <span class="token operator">=</span> <span class="token string">"prod"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>then
  target_host<span class="token operator">=</span>$prod_host
fi

ssh $<span class="token punctuation">{</span>target_host<span class="token punctuation">}</span> <span class="token operator">&lt;</span><span class="token operator">&lt;</span>END
  docker rmi \<span class="token function">$</span><span class="token punctuation">(</span>docker images <span class="token operator">--</span>filter <span class="token string">"dangling=true"</span> <span class="token operator">-</span>q <span class="token operator">--</span>no<span class="token operator">-</span>trunc<span class="token punctuation">)</span>
  rm <span class="token operator">-</span>rf <span class="token operator">/</span>tmp<span class="token operator">/</span>Sira
  git clone git@github<span class="token punctuation">.</span>com<span class="token punctuation">:</span>metrue<span class="token operator">/</span>Sira<span class="token punctuation">.</span>git <span class="token operator">/</span>tmp<span class="token operator">/</span>Sira
  cd <span class="token operator">/</span>tmp<span class="token operator">/</span>Sira
  docker<span class="token operator">-</span>compose <span class="token operator">-</span>f devops<span class="token operator">/</span>compose<span class="token punctuation">.</span>yml down
  docker<span class="token operator">-</span>compose <span class="token operator">-</span>f devops<span class="token operator">/</span>compose<span class="token punctuation">.</span>yml build <span class="token operator">&amp;&amp;</span> docker<span class="token operator">-</span>compose <span class="token operator">-</span>f devops<span class="token operator">/</span>compose<span class="token punctuation">.</span>yml up <span class="token operator">-</span>d
END</code></pre><pre><code class="lang-undefined"># Makefile

deploy<span class="token operator">-</span>dev<span class="token punctuation">:</span>
    devops<span class="token operator">/</span>deploy<span class="token punctuation">.</span>sh dev
deploy<span class="token operator">-</span>prod<span class="token punctuation">:</span>
    devops<span class="token operator">/</span>deploy<span class="token punctuation">.</span>sh prod</code></pre><p>你可以看到我们将生产环境和开发环境进行了分离，而且每一次的部署都经历三步:</p>
<ul>
<li>删掉无用的旧 docker images</li>
<li>重新clone代码做clean build</li>
<li>停止之前的services</li>
<li>最后build各项服务，而且启动</li>
</ul>
<p>这其实就是一个很小但是五脏俱全的pipeline了，这样我们就可以在本地的部署了</p>
<pre><code class="lang-undefined">make deploy<span class="token operator">-</span>dev   # 部署到 dev 环境
make deploy<span class="token operator">-</span>prod  # 部署到 prod 环境</code></pre></article></section><footer class="footer">
  Copyright ©2014-2017 <a href="http://minghe.me"> minghe.me</a> | Powered by <a href="https://github.com/metrue/Seal">Seal</a> on top of <a href="https://vuejs.org" target="_blank">Vue.js</a></footer></html>