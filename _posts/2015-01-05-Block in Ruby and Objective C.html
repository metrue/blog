<html server-rendered="true"><head><meta charset="UTF-8"> <meta name="viewport" content="initial-scale=1,maximum-scale=1,minimum-scale=1,width=device-width,user-scalable=no"> <meta name="renderer" content="webkit"> <meta name="theme-color" content="#ffffff"> <link href="/css/build.HomePage.css" rel="stylesheet"> <link href="/css/build.PostPage.css" rel="stylesheet"> <title> Minghe </title></head><section class="post-view"><h1 class="post-title">
    Block in Ruby and Objective C
    <time pubdate="pubdate" class="post-date"></time></h1> <article><p>在 Ruby 和 Objective C 中都存在 block 这个很好玩的东西， 在 Javascript 和其他的语言中，一般称为闭包 ( closure ).  而其本质基本上是一样: bock/closure 是一个函数或者指向函数的指针，以及其执行的上下文变量。但是在不同的语言中， block 的具体体现略为不同，Ruby 的 block 非常的简洁易懂， 而 Objective C 的 block 基本上保持 C 语言中函数指针的形式。 无论在 Objective C 还是 Ruby， 或者其他语言中，block/closure 的作用都是: 穿越作用域 和 完成特定的运算功能。本文我们就来对比一下 block 在 Ruby 和 Objective C 中是如何实现这两个功能的。</p>
<h3 id="block-的基本形式">Block 的基本形式</h3><p>Ruby 中的 Block 只有两种形式:</p>
<ul>
<li>大括号包围的形式<pre><code class="lang-undefined"><span class="token punctuation">{</span> block body <span class="token punctuation">}</span></code></pre></li>
<li>do end 包围的形式<pre><code class="lang-undefined"><span class="token keyword">do</span>
  block body
end</code></pre></li>
</ul>
<p>Ruby 中几乎所有的东西都是对象，但是上面的 Block 却不是，那么 Ruby 是否可以让 Block 也成为一种对象呢，这样就可以将 Block 保存起来以后使用了。 当然是有的，Proc 和 Lambda</p>
<pre><code class="lang-undefined">dec <span class="token operator">=</span> proc <span class="token punctuation">{</span> <span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span>
dec<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">></span> <span class="token number">0</span></code></pre><pre><code class="lang-undefined">inc <span class="token operator">=</span> lambda <span class="token punctuation">{</span> <span class="token operator">|</span>x<span class="token operator">|</span> x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span>
inc<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">></span> <span class="token number">2</span></code></pre><p>Proc 和 Lambda 的区别是: Lambda 由对参数格式要求严格，也就是调用 Lambda 的使用参数必须和创建 Lambda 的时候一致，其次，return 在 Lambda 中表示从 Lambda 中返回，而在Proc 则表示从定义 Proc 的作用域中返回。所以如果你在 <main> 中定义 Proc，在 Proc 中使用 return 的时候会遇到这样的错误:</p>
<pre><code class="lang-undefined"><span class="token keyword">in</span> <span class="token template-string"><span class="token string">`block in &lt;main>’: unexpected return (LocalJumpError)&lt;/main>`</span></span></code></pre><p>而在 Objective C 中 Block 看起来很纠结，手写起来太容易出错了， 我一般是这样来记忆 Objective C 中的 Block:</p>
<ul>
<li>当 Block 作为左值时</li>
</ul>
<pre><code class="lang-undefined">returnType <span class="token punctuation">(</span><span class="token operator">^</span>blockName<span class="token punctuation">)</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span></code></pre><ul>
<li>当 Block 作为右值时:</li>
</ul>
<pre><code class="lang-undefined"><span class="token operator">^</span><span class="token function">returnType</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span> blockBody <span class="token punctuation">}</span></code></pre><p>基于上面的原则我们可以很快写出 Block 的几种基本使用场景:</p>
<ul>
<li>作为局部变量</li>
</ul>
<pre><code class="lang-undefined">returnType <span class="token punctuation">(</span><span class="token operator">^</span>blockName<span class="token punctuation">)</span><span class="token punctuation">(</span>parametertypes<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token function">returnType</span><span class="token punctuation">(</span>parameterts<span class="token punctuation">)</span> <span class="token punctuation">{</span> blockBody<span class="token punctuation">}</span></code></pre><ul>
<li>作为属性</li>
</ul>
<pre><code class="lang-undefined">@property <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> returnType <span class="token punctuation">(</span><span class="token operator">^</span>blockName<span class="token punctuation">)</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span></code></pre><ul>
<li>作为定义方法时候的参数(parameter)</li>
</ul>
<pre><code class="lang-undefined"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>someMethodThatTakesABlock<span class="token punctuation">:</span><span class="token punctuation">(</span>returnType <span class="token punctuation">(</span><span class="token operator">^</span><span class="token punctuation">)</span><span class="token punctuation">(</span>parametertTypes<span class="token punctuation">)</span><span class="token punctuation">)</span>blockName<span class="token punctuation">;</span></code></pre><ul>
<li>作为调用方法时候的传递参数(argument)</li>
</ul>
<pre><code class="lang-undefined"><span class="token punctuation">[</span>someObject someMethodThatTakesABlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token function">returnType</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span> blockBody <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul>
<li>使用 typedef 定义一个 Block 类型</li>
</ul>
<pre><code class="lang-undefined">typedef returnType <span class="token punctuation">(</span><span class="token operator">^</span>TypeName<span class="token punctuation">)</span><span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
TypeName blockName <span class="token operator">=</span> <span class="token operator">^</span><span class="token function">returnType</span><span class="token punctuation">(</span>parameterts<span class="token punctuation">)</span> <span class="token punctuation">{</span> blockBody <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><ul>
<li><p>inline Block<br>这中 Block 正如 Block 的字面意思一样，就是一个代码段，也分为有参和无参两种</p>
</li>
<li><p>有参</p>
</li>
</ul>
<pre><code class="lang-undefined"><span class="token operator">^</span>returnType <span class="token punctuation">(</span>parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    blockBody<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span>parameterts<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul>
<li>无参:</li>
</ul>
<pre><code class="lang-undefined"><span class="token punctuation">{</span>
    blockBody<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><h3 id="block-的威力">Block 的威力</h3><p>正如前面说的，Block 的作用可以总结为: 穿越作用域，以及完成特定运算。</p>
<ul>
<li>穿越作用域</li>
</ul>
<p>对于 Ruby 来说，分隔作用域的三道门为: class, module, def。 为了是得变量可以穿越这三道门，我们可以使用 Class.new 代替 class 去定义一个类， 使用 Module.new 去代替 module 去定义一个 module，以及使用 define_method 去代替 def 去定义个方法，这样上下文的变量就可以在定义中得到使用了。</p>
<pre><code class="lang-undefined"><span class="token keyword">var</span> <span class="token operator">=</span> “foo”
MyClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">do</span>
  puts “#<span class="token punctuation">{</span><span class="token keyword">var</span><span class="token punctuation">}</span> is <span class="token keyword">in</span> MyClass now”
end</code></pre><p>他们的区别是，class 和 module 定义中的代码会马上执行，而方法定义中的代码之用在调用的时候才会执行。</p>
<p>对于 Objective C 来说，作用域的概念基本上都是继承于 C 的，和本文内容相关时 blockBody 如何访问上下文变量的问题, 基本上和 Ruby 一样。</p>
<pre><code class="lang-undefined">NSString x <span class="token operator">=</span> @”hello world”<span class="token punctuation">;</span>

<span class="token operator">^</span><span class="token punctuation">{</span>
  <span class="token function">NSLog</span><span class="token punctuation">(</span>@“<span class="token operator">%</span>@”<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><ul>
<li>完成特定的预算</li>
</ul>
<p>由于可以在 Block 的 blockBody 完成任意的操作，所以 Block 无论是在 Ruby 还是 Objective C 中都有这广泛的运用，也是 Ruby 和 Objective C 中的一等公民。比如Ruby 中内置的数据类型的绝大多数操作都支持 Block，如 Array 中的 each, Hash中的each_pair 等，而在 Rails, Jekyll, Grape 等优秀的基于 Ruby 的框架中，Block 的使用就更加频繁和优雅了。 同样在 Objective C 中，可以说没有 Block 就没有Objective C, iOS 中 Cocoa 里面大量的设计模式都必须有 Block 作为支撑。而大量的优秀的开源框架更是将 Block 用的微妙微翘, 比如我们经常使用的 AFNetworking 框架，在 HTTP GET 的 succecss 和 failure 的处理函数都是使用的是 Block. 所以深入理解 Block 是学习 Ruby 和 iOS 开发的基础，甚至对于理解其他语言如 Javascript 都是非常有意义的。</p>
</article></section><footer class="footer">
  Copyright ©2014-2017 <a href="http://minghe.me"> minghe.me</a> | Powered by <a href="https://github.com/***REMOVED***/Seal">Seal</a> on top of <a href="https://vuejs.org" target="_blank">Vue.js</a></footer></html>