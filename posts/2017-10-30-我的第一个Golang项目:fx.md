## 前言

fx 是我在 [Go Hack](http://gohack2017.golangfoundation.org/)的一个小作品，Go Hack 是一个以Go语言为主要编程语言的黑客马拉松比赛。虽然我和我队友两人都是写JavaScript的前端工程师, 以Golang 零基础参加这次比赛，不过很开心我们完成了fx，也喜欢上 Golang 这门语言.


读了那么多年书，写了那么久的代码，如果说有什么概念是深入骨髓的，只能说是”函数“了。虽然在数学上和编程上，“函数”这个词有很大的不一样的，但是有一点上它们是类似:

```
接受输入（可能为空值），然后进行处理，最后输出处理结果。
```

我们几乎可以用这个概念来描述所有的行为. 比如我们可以用下面的函数的来描述我们 fx 的诞生过程：

```
函数 f = Go Hack (以 Golang 为项目编程语言的黑客马拉松活动)
输入 input = [两个Go语言零基础的JavaScript工程师，两台Macbook，很多很多的功能饮料]
fx = f(input)
```

## fx 是什么

那么 fx 是什么呢，一句话来说就是 : fx 是一个可以把一个函数变成一个服务的工具.  一个简单的例子来说一下 fx 的功能吧. 比如你写好了很棒的函数 , 它是这样的:

func.js
```
module.exports = (input) => {
    return parseInt(input.a, 10) + parseInt(input.b, 10)
}
```

它的作用就是计算两个数的和.  你把这个函数写在 `func.js ` 这个文件里面。 这时候你希望可以将这个函数编程一个服务，对外提供一个 url 可以供外界访问.  但是想到 nginx, web server,  api gateway…, 你头有点大了。 现在你可以简单的这样做。

```
fx up func.js
```

如果一切没有什么问题，你可以得到一个url.

```
$fx list
Function ID	Service URL
743a9b0ee5	0.0.0.0:61098
```

访问你的服务试试看

```
$ curl -X POST 0.0.0.0:61098 -H "Content-Type: application/json" -d '{"a": 1, "b": 1}'
```

你会得到 `2`. 这说明你的函数已经变成了一个服务了。


## fx 如何工作

```
				upload function definition
fx client   -------------------------------> fx server
			<-------------------------------
				url of deployed service
```

fx 有两个部分组成，fx server 和 fx client . client 很简单，主要就是把 function 的定义内容通过 Websocket 发给 server 而已，而 server 是一个 Websocket sever，接受到 function 的内容了之后，匹配到正确的 Dockerfile 和对应的构建镜像所需的资源, 然后会调用 Docker Engine 的 api 去构建相应的服务，最后把生成的服务的 URL 返回给客户端.

## fx 支持哪些编程语言

由于 fx 的一个服务的背后都是一个 Docker Container, 所以 fx 几乎可以支持所有的编程语言，由于精力有限，目前 fx 支持这些编程语言:
* Golang
* JavaScript/Node
* Ruby
* Python
* Java
* PHP
* Julia

## fx 的未来

啥未来，就是一个小工具而已。

